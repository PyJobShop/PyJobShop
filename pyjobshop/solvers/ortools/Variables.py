from dataclasses import dataclass
from typing import TypeAlias

from ortools.sat.python.cp_model import (
    BoolVarT,
    CpModel,
    Domain,
    IntervalVar,
    IntVar,
    LinearExprT,
)

from pyjobshop.constants import MAX_VALUE
from pyjobshop.ProblemData import ProblemData
from pyjobshop.Solution import Solution

TaskIdx = int
ResourceIdx = int
TaskResIdcs = tuple[TaskIdx, ResourceIdx]
ModeVar: TypeAlias = IntVar  # actually BoolVarT


@dataclass
class JobVar:
    """
    Variables that represent a job in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the job.
    """

    interval: IntervalVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class TaskVar:
    """
    Variables that represent a task in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the task.
    present
        The boolean variable indicating whether the interval is present.
    processing
        The integer variable representing the processing time of the task.
    idle
        The integer variable representing the idle time of the task.
    overlap
        The integer variable representing the break overlap time of the task.
    """

    interval: IntervalVar
    present: IntervalVar
    processing: IntVar
    idle: IntVar
    overlap: IntVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class OptionalIntervalVar:
    """
    Wrapper around the OR-Tools interval variable, which does not expose
    the ``present`` variable.

    Parameters
    ----------
    interval
        The interval variable to be represented.
    present
        The Boolean variable indicating whether the interval is present.
    """

    interval: IntervalVar
    present: BoolVarT

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


class SequenceVar:
    """
    Represents the sequence of interval variables for all tasks that may
    be assigned to this machine.

    Parameters
    ----------
    tasks
        The list of task indices that can be assigned to this resource. Tasks
        combined with a dummy node represent the graph of this variable.

    Attributes
    ----------
    arcs
        The arc literals between each pair of intervals indicating whether
        intervals are scheduled directly behind each other. Includes arcs
        to and from a dummy node for each interval.
    is_active
        A Boolean that indicates whether the sequence is active, meaning that a
        circuit constraint must be added for this machine. Default ``False``.

    Notes
    -----
    A sequence variable represents a complete graph of the tasks that can be
    assigned to a resource. The nodes include all tasks and a dummy node, which
    is required to obtain a correct permutation of present tasks in this
    sequence. The arcs of a sequence variable are lazily generated by the
    ``activate()`` method. This avoids creating arcs when it's not used in the
    model, because creating them is very expensive (takes quadratic time).

    """

    DUMMY = -1

    def __init__(self, tasks: list[int]):
        self._tasks = tasks
        self._arcs: dict[tuple[TaskIdx, TaskIdx], BoolVarT] = {}
        self._is_active = False

    @property
    def arcs(self) -> dict[tuple[TaskIdx, TaskIdx], BoolVarT]:
        """
        Returns the arcs of the sequence variable.
        """
        return self._arcs

    @property
    def is_active(self) -> bool:
        """
        Returns whether the sequence variable is active.
        """
        return self._is_active

    def activate(self, model: CpModel):
        """
        Activates the sequence variable by creating all relevant literals.
        """
        if self.is_active:
            return

        self._is_active = True

        nodes = [*self._tasks, self.DUMMY]
        self._arcs = {
            (i, j): model.new_bool_var(f"{i}->{j}")
            for i in nodes
            for j in nodes
        }


@dataclass
class OverlapVar:
    """
    Variable representing whether an interval overlaps with a resource break.
    It's used to allow tasks intervals to be interrupted by breaks, and resume
    processing afterwards.

    Parameters
    ----------
    before
        Boolean variable indicating whether the interval ends before the
        break starts.
    after
        Boolean variable indicating whether the interval starts after the
        break ends.
    overlaps
        Boolean variable indicating whether the interval overlaps with the
        break.
    duration
        Integer variable representing the duration of the overlap (0 if no
        overlap, otherwise the length of the break).
    break_time
        The (start, end) time of the break that belongs to this overlap
        variable.
    """

    before: BoolVarT
    after: BoolVarT
    overlaps: BoolVarT
    duration: IntVar
    break_time: tuple[int, int]


class Variables:
    """
    Manages the core variables of the OR-Tools model.
    """

    def __init__(self, model: CpModel, data: ProblemData):
        self._model = model
        self._data = data

        self._job_vars = self._make_job_variables()
        self._task_vars = self._make_task_variables()
        self._mode_vars = [model.new_bool_var("") for _ in self._data.modes]
        self._assign_vars = self._make_assign_variables(self._task_vars)
        self._demand_vars = self._make_demand_variables()
        self._sequence_vars = self._make_sequence_variables()

        # Variables below are lazily created.
        self._overlap_vars: list[list[OverlapVar]] | None = None
        self._makespan_var: IntVar | None = None
        self._is_tardy_vars: list[IntVar] | None = None
        self._flow_time_vars: list[IntVar] | None = None
        self._tardiness_vars: list[IntVar] | None = None
        self._earliness_vars: list[IntVar] | None = None
        self._max_tardiness_var: IntVar | None = None

    @property
    def job_vars(self) -> list[JobVar]:
        """
        Returns the job variables.
        """
        return self._job_vars

    @property
    def task_vars(self) -> list[TaskVar]:
        """
        Returns the task variables.
        """
        return self._task_vars

    @property
    def mode_vars(self) -> list[ModeVar]:
        """
        Returns the mode variables.
        """
        return self._mode_vars

    @property
    def assign_vars(self) -> dict[TaskResIdcs, OptionalIntervalVar]:
        """
        Retruns the assignment variables.
        """
        return self._assign_vars

    @property
    def demand_vars(self) -> dict[TaskResIdcs, IntVar]:
        """
        Returns the demand variables.
        """
        return self._demand_vars

    @property
    def sequence_vars(self) -> dict[int, SequenceVar]:
        """
        Returns the sequence variables.
        """
        return self._sequence_vars

    @property
    def overlap_vars(self) -> list[list[OverlapVar]]:
        """
        Returns the overlap variables for each mode.
        """
        if self._overlap_vars is not None:
            return self._overlap_vars

        self._overlap_vars = self._make_overlap_variables()
        return self._overlap_vars

    @property
    def makespan_var(self) -> IntVar:
        """
        Returns the makespan variable, creating it if it does not exist.
        """
        if self._makespan_var is not None:
            return self._makespan_var

        self._makespan_var = self._make_makespan_variable()
        return self._makespan_var

    @property
    def is_tardy_vars(self) -> list[IntVar]:
        """
        Returns the Boolean variables indicating whether each job is tardy,
        creating them if they do not exist.
        """
        if self._is_tardy_vars is not None:
            return self._is_tardy_vars

        self._is_tardy_vars = self._make_is_tardy_variables()
        return self._is_tardy_vars

    @property
    def flow_time_vars(self) -> list[IntVar]:
        """
        Returns the flow time variables for each job, creating them if they do
        not exist.
        """
        if self._flow_time_vars is not None:
            return self._flow_time_vars

        self._flow_time_vars = self._make_flow_time_variables()
        return self._flow_time_vars

    @property
    def tardiness_vars(self) -> list[IntVar]:
        """
        Returns the tardiness variables for each job, creating them if they do
        not exist.
        """
        if self._tardiness_vars is not None:
            return self._tardiness_vars

        self._tardiness_vars = self._make_tardiness_variables()
        return self._tardiness_vars

    @property
    def earliness_vars(self) -> list[IntVar]:
        """
        Returns the earliness variables for each job, creating them if they do
        not exist.
        """
        if self._earliness_vars is not None:
            return self._earliness_vars

        self._earliness_vars = self._make_earliness_variables()
        return self._earliness_vars

    @property
    def max_tardiness_var(self) -> IntVar:
        """
        Returns the maximum tardiness variable, creating it if it does not
        exist.
        """
        if self._max_tardiness_var is not None:
            return self._max_tardiness_var

        self._max_tardiness_var = self._make_max_tardiness_variable()
        return self._max_tardiness_var

    def res2assign(self, idx: int) -> list[OptionalIntervalVar]:
        """
        Returns all assignment variables for the given resource.
        """
        items = self.assign_vars.items()
        return [var for (_, res_idx), var in items if res_idx == idx]

    def res2demand(self, idx: int) -> list[IntVar]:
        """
        Returns all demand variables for the given resource.
        """
        items = self.demand_vars.items()
        return [var for (_, res_idx), var in items if res_idx == idx]

    def _make_job_variables(self) -> list[JobVar]:
        """
        Creates an interval variable for each job.
        """
        model, data = self._model, self._data
        variables = []

        for idx, job in enumerate(data.jobs):
            name = f"J{idx}"
            start = model.new_int_var(
                lb=job.release_date,
                ub=MAX_VALUE,
                name=f"{name}_start",
            )
            duration = model.new_int_var(
                lb=0,
                ub=min(job.deadline - job.release_date, MAX_VALUE),
                name=f"{name}_duration",
            )
            end = model.new_int_var(
                lb=0,
                ub=min(job.deadline, MAX_VALUE),
                name=f"{name}_end",
            )
            interval = model.new_interval_var(
                start, duration, end, f"{name}_interval"
            )
            variables.append(JobVar(interval))

        return variables

    def _make_task_variables(self) -> list[TaskVar]:
        """
        Creates an interval variable for each task.
        """
        model, data = self._model, self._data
        variables = []

        for idx, task in enumerate(data.tasks):
            name = f"T{idx}"
            present = (
                model.new_bool_var(f"{name}_present")
                if task.optional
                else model.new_constant(True)
            )

            start = model.new_int_var(lb=0, ub=MAX_VALUE, name=f"{name}_start")
            model.add(start >= task.earliest_start).only_enforce_if(present)
            model.add(start <= task.latest_start).only_enforce_if(present)

            end = model.new_int_var(lb=0, ub=MAX_VALUE, name=f"{name}_end")
            model.add(end >= task.earliest_end).only_enforce_if(present)
            model.add(end <= task.latest_end).only_enforce_if(present)

            modes = [data.modes[mode_idx] for mode_idx in data.task2modes(idx)]
            domain = Domain.from_values([mode.duration for mode in modes])
            processing = model.new_int_var_from_domain(
                domain, name=f"{name}_processing"
            )
            processing = model.new_int_var(0, MAX_VALUE, f"{name}_processing")
            model.add_linear_expression_in_domain(
                processing, domain
            ).only_enforce_if(present)

            idle = model.new_int_var(0, MAX_VALUE, f"{name}_idle")
            overlap = model.new_int_var(0, MAX_VALUE, f"{name}_overlap")
            duration = model.new_int_var(0, MAX_VALUE, f"{name}_duration")
            model.add(duration == processing + idle + overlap)

            if not task.allow_breaks:
                model.add(overlap == 0)

            if not task.allow_idle:
                model.add(idle == 0)

            interval = model.new_optional_interval_var(
                start, duration, end, present, f"{name}_interval"
            )
            variables.append(
                TaskVar(interval, present, processing, idle, overlap)
            )

        return variables

    def _make_assign_variables(
        self, task_vars: list[TaskVar]
    ) -> dict[TaskResIdcs, OptionalIntervalVar]:
        """
        Creates an optional interval variable for each task-resource pair.
        """
        model, data = self._model, self._data
        variables = {}

        for task_idx in range(data.num_tasks):
            # Only create assignment variables for (task, resource) pairs
            # that are actually used in the problem.
            resources = {
                res
                for mode in data.task2modes(task_idx)
                for res in data.modes[mode].resources
            }

            for res_idx in resources:
                name = f"A_{task_idx}_{res_idx}"
                task_var = task_vars[task_idx]
                present = model.new_bool_var(f"{name}_present")
                interval = model.new_optional_interval_var(
                    task_var.start,
                    task_var.duration,
                    task_var.end,
                    present,
                    f"{name}_interval",
                )
                var = OptionalIntervalVar(interval, present)
                variables[task_idx, res_idx] = var

        return variables

    def _make_demand_variables(
        self,
    ) -> dict[TaskResIdcs, IntVar]:
        """
        Creates a integer demand variable for each task-resource pair.
        """
        model, data = self._model, self._data
        variables = {}

        for task_idx in range(data.num_tasks):
            # Only create demand variables for (task, resource) pairs
            # that are actually used in the problem.
            resources = {
                res
                for mode in data.task2modes(task_idx)
                for res in data.modes[mode].resources
            }

            for res_idx in resources:
                name = f"{task_idx}_{res_idx}"
                demand = model.new_int_var(0, MAX_VALUE, f"{name}_demand")
                variables[task_idx, res_idx] = demand

        return variables

    def _make_sequence_variables(self) -> dict[ResourceIdx, SequenceVar]:
        """
        Creates a sequence variable for each machine.
        """
        data = self._data
        variables: dict[ResourceIdx, SequenceVar] = {}

        for idx in data.machine_idcs:
            tasks = {data.modes[m].task for m in data.resource2modes(idx)}
            variables[idx] = SequenceVar(sorted(tasks))

        return variables

    def _make_overlap_variables(self) -> list[list[OverlapVar]]:
        """
        Creates the overlap variables.
        """
        model, data = self._model, self._data
        variables: list[list[OverlapVar]] = []

        for mode_idx, mode in enumerate(data.modes):
            breaks = [
                brk
                for res_idx in mode.resources
                for brk in getattr(data.resources[res_idx], "breaks", [])
            ]
            breaks = merge(breaks)  # super breaks
            task_var = self._task_vars[mode.task]
            mode_var = self._mode_vars[mode_idx]
            overlap_vars = []

            for start, end in breaks:
                before = model.new_bool_var("")
                model.add(task_var.end <= start).only_enforce_if(
                    [before, mode_var]
                )
                model.add(task_var.end > start).only_enforce_if(
                    [~before, mode_var]
                )

                after = model.new_bool_var("")
                model.add(task_var.start >= end).only_enforce_if(
                    [after, mode_var]
                )
                model.add(task_var.start < end).only_enforce_if(
                    [~after, mode_var]
                )

                overlaps = model.new_bool_var("")
                model.add_bool_or(after, before, overlaps)
                model.add_implication(after, ~overlaps)
                model.add_implication(before, ~overlaps)

                # Overlap duration is either zero or the break duration.
                domain = Domain.from_values([0, end - start])
                duration = model.new_int_var_from_domain(domain, "")
                model.add(duration == end - start).only_enforce_if(overlaps)
                model.add(duration == 0).only_enforce_if(~overlaps)

                overlap_var = OverlapVar(
                    before,
                    after,
                    overlaps,
                    duration,
                    (start, end),
                )
                overlap_vars.append(overlap_var)

            variables.append(overlap_vars)

        return variables

    def _make_makespan_variable(self) -> IntVar:
        """
        Creates the makespan variable.
        """
        makespan_var = self._model.new_int_var(0, MAX_VALUE, "makespan")

        if self._task_vars:
            # Need at least one task to enforce this constraint.
            completion_times = [var.end for var in self.task_vars]
            self._model.add_max_equality(makespan_var, completion_times)

        return makespan_var

    def _make_is_tardy_variables(self) -> list[IntVar]:
        """
        Creates the Boolean variables indicating whether each job is tardy.
        """
        model, data = self._model, self._data
        is_tardy_vars = []

        for job, job_var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            is_tardy = model.new_bool_var(f"is_tardy_{job}")
            model.add(job_var.end > job.due_date).only_enforce_if(is_tardy)
            model.add(job_var.end <= job.due_date).only_enforce_if(~is_tardy)
            is_tardy_vars.append(is_tardy)

        return is_tardy_vars

    def _make_flow_time_variables(self) -> list[IntVar]:
        """
        Creates the flow time variables for each job.
        """
        model, data = self._model, self._data
        flow_time_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            flow_time = model.new_int_var(0, MAX_VALUE, f"flow_time_{job}")
            model.add_max_equality(flow_time, [0, var.end - job.release_date])
            flow_time_vars.append(flow_time)

        return flow_time_vars

    def _make_tardiness_variables(self) -> list[IntVar]:
        """
        Creates the tardiness variables for each job.
        """
        model, data = self._model, self._data
        tardiness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            tardiness = model.new_int_var(0, MAX_VALUE, f"tardiness_{job}")
            model.add_max_equality(tardiness, [0, var.end - job.due_date])
            tardiness_vars.append(tardiness)

        return tardiness_vars

    def _make_earliness_variables(self) -> list[IntVar]:
        """
        Creates the earliness variables for each job.
        """
        model, data = self._model, self._data
        earliness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            earliness = model.new_int_var(0, MAX_VALUE, f"earliness_{job}")
            model.add_max_equality(earliness, [0, job.due_date - var.end])
            earliness_vars.append(earliness)

        return earliness_vars

    def _make_max_tardiness_variable(self) -> IntVar:
        """
        Creates the maximum tardiness variable.
        """
        model = self._model
        max_tardiness_var = model.new_int_var(0, MAX_VALUE, "max_tardiness")

        if self._job_vars:
            # Need at least one job to enforce this constraint.
            tardiness_vars = [
                job.weight * var
                for job, var in zip(self._data.jobs, self.tardiness_vars)
            ]
            model.add_max_equality(max_tardiness_var, tardiness_vars)

        return max_tardiness_var

    def warmstart(self, solution: Solution):
        """
        Warmstarts the variables based on the given solution.
        """
        model, data = self._model, self._data
        job_vars, task_vars, assign_vars = (
            self.job_vars,
            self.task_vars,
            self.assign_vars,
        )
        sol_tasks = solution.tasks

        model.clear_hints()

        # Job related variables.
        max_tardiness = 0
        for task_idx in range(data.num_jobs):
            job = data.jobs[task_idx]
            job_var = job_vars[task_idx]
            job_sol_tasks = [sol_tasks[task] for task in job.tasks]

            job_start = min(task.start for task in job_sol_tasks)
            job_end = max(task.end for task in job_sol_tasks)
            job_duration = job_end - job_start

            model.add_hint(job_var.start, job_start)  # type: ignore
            model.add_hint(job_var.duration, job_duration)  # type: ignore
            model.add_hint(job_var.end, job_end)  # type: ignore

            if data.objective.weight_total_flow_time > 0:
                flow_time = job_end - job.release_date
                model.add_hint(self.flow_time_vars[task_idx], flow_time)

            if job.due_date is not None:
                if data.objective.weight_tardy_jobs > 0:
                    is_tardy = job_end > job.due_date
                    model.add_hint(self.is_tardy_vars[task_idx], is_tardy)

                if data.objective.weight_total_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    model.add_hint(self.tardiness_vars[task_idx], tardiness)

                if data.objective.weight_total_earliness > 0:
                    earliness = max(0, job.due_date - job_end)
                    model.add_hint(self.earliness_vars[task_idx], earliness)

                if data.objective.weight_max_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    max_tardiness = max(max_tardiness, tardiness)

        if data.objective.weight_max_tardiness > 0:
            model.add_hint(self.max_tardiness_var, max_tardiness)

        if data.objective.weight_makespan > 0:
            model.add_hint(self.makespan_var, solution.makespan)

        # Task and mode related variables.
        for task_idx in range(data.num_tasks):
            task_var = task_vars[task_idx]
            sol_task = solution.tasks[task_idx]
            task_duration = sol_task.end - sol_task.start

            model.add_hint(task_var.start, sol_task.start)  # type: ignore
            model.add_hint(task_var.end, sol_task.end)  # type: ignore
            model.add_hint(task_var.idle, sol_task.idle)  # type: ignore
            model.add_hint(task_var.overlap, sol_task.overlap)  # type: ignore
            processing = task_duration - sol_task.idle - sol_task.overlap
            model.add_hint(task_var.processing, processing)  # type: ignore
            model.add_hint(task_var.duration, task_duration)  # type: ignore

            if data.tasks[task_idx].optional:
                # OR-Tools complains about adding hints to interval
                # variables that are always present.
                model.add_hint(task_var.present, sol_task.present)

            for mode_idx in data.task2modes(task_idx):
                mode_var = self.mode_vars[mode_idx]
                mode_selected = mode_idx == sol_task.mode
                model.add_hint(mode_var, mode_selected)

                # Overlap related variables.
                for overlap_var in self.overlap_vars[mode_idx]:
                    break_start, break_end = overlap_var.break_time
                    before = sol_task.end <= break_start
                    after = sol_task.start >= break_end
                    overlaps = mode_selected and not (before or after)
                    model.add_hint(overlap_var.overlaps, overlaps)
                    model.add_hint(overlap_var.before, before)
                    model.add_hint(overlap_var.after, after)
                    model.add_hint(
                        overlap_var.duration,
                        (break_end - break_start)
                        if mode_selected and overlaps
                        else 0,
                    )

            mode_data = data.modes[sol_task.mode]
            res2demands = dict(zip(mode_data.resources, mode_data.demands))

            task_resources = set()
            for mode in data.task2modes(task_idx):
                task_resources.update(data.modes[mode].resources)

            for res_idx in task_resources:
                assign_var = assign_vars[task_idx, res_idx]
                is_present = res_idx in sol_task.resources
                model.add_hint(assign_var.present, is_present)

                demand_var = self.demand_vars[task_idx, res_idx]
                model.add_hint(demand_var, res2demands.get(res_idx, 0))

        # Sequencing related variables.
        for res_idx in data.machine_idcs:
            seq_var = self.sequence_vars[res_idx]
            if not seq_var.is_active:
                continue

            # Identify the tasks assigned to this machine.
            tasks = {data.modes[m].task for m in data.resource2modes(res_idx)}
            assigned = {
                idx for idx in tasks if res_idx in sol_tasks[idx].resources
            }

            # Identify the first and last task in the sequence.
            def task_start(idx):
                return sol_tasks[idx].start

            first = min(assigned, default=None, key=task_start)
            last = max(assigned, default=None, key=task_start)

            for (idx1, idx2), arc in seq_var.arcs.items():
                if idx1 == seq_var.DUMMY and idx2 == seq_var.DUMMY:
                    hint = not assigned
                elif idx1 == seq_var.DUMMY:
                    hint = idx2 == first
                elif idx2 == seq_var.DUMMY:
                    hint = idx1 == last
                elif idx1 == idx2:
                    hint = idx1 not in assigned
                else:
                    # TODO There's an edge case when the task duration is 0.
                    # Revisit after #257.
                    hint = (
                        idx1 in assigned
                        and idx2 in assigned
                        and sol_tasks[idx1].start < sol_tasks[idx2].start
                    )

                model.add_hint(arc, hint)


def merge(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]:
    if not intervals:
        return []

    intervals = sorted(intervals)
    merged: list[tuple[int, int]] = []

    for start, end in intervals:
        if not merged or start > merged[-1][1]:
            merged.append((start, end))  # no overlap
        else:
            new_end = max(merged[-1][1], end)  # overlap -> merge with last
            merged[-1] = (merged[-1][0], new_end)

    return merged
