from dataclasses import dataclass
from typing import TypeAlias

from ortools.sat.python.cp_model import (
    BoolVarT,
    CpModel,
    Domain,
    IntervalVar,
    IntVar,
    LinearExprT,
)

from pyjobshop.constants import MAX_VALUE
from pyjobshop.ProblemData import ProblemData
from pyjobshop.Solution import Solution
from pyjobshop.solvers.ortools.utils import (
    partition_task_start_by_break_overlap,
)
from pyjobshop.solvers.utils import merge

TaskIdx = int
ResourceIdx = int
TaskResIdcs = tuple[TaskIdx, ResourceIdx]
ModeVar: TypeAlias = IntVar  # actually BoolVarT


@dataclass
class JobVar:
    """
    Variables that represent a job in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the job.
    """

    interval: IntervalVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class TaskVar:
    """
    Variables that represent a task in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the task.
    present
        The boolean variable indicating whether the interval is present.
    processing
        The integer variable representing the processing time of the task.
    idle
        The integer variable representing the idle time of the task.
    breaks
        The integer variable representing the break times of the task.
    """

    interval: IntervalVar
    present: BoolVarT
    processing: IntVar
    idle: IntVar
    breaks: IntVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class OptionalIntervalVar:
    """
    Wrapper around the OR-Tools interval variable, which does not expose
    the ``present`` variable.

    Parameters
    ----------
    interval
        The interval variable to be represented.
    present
        The Boolean variable indicating whether the interval is present.
    """

    interval: IntervalVar
    present: BoolVarT

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


class SequenceVar:
    """
    Represents the sequence of interval variables for all tasks that may
    be assigned to this machine.

    Parameters
    ----------
    tasks
        The list of task indices that can be assigned to this resource. Tasks
        combined with a dummy node represent the graph of this variable.

    Attributes
    ----------
    arcs
        The arc literals between each pair of intervals indicating whether
        intervals are scheduled directly behind each other. Includes arcs
        to and from a dummy node for each interval.
    is_active
        A Boolean that indicates whether the sequence is active, meaning that a
        circuit constraint must be added for this machine. Default ``False``.

    Notes
    -----
    A sequence variable represents a complete graph of the tasks that can be
    assigned to a resource. The nodes include all tasks and a dummy node, which
    is required to obtain a correct permutation of present tasks in this
    sequence. The arcs of a sequence variable are lazily generated by the
    ``activate()`` method. This avoids creating arcs when it's not used in the
    model, because creating them is very expensive (takes quadratic time).

    """

    DUMMY = -1

    def __init__(self, tasks: list[int]):
        self._tasks = tasks
        self._arcs: dict[tuple[TaskIdx, TaskIdx], BoolVarT] = {}
        self._is_active = False

    @property
    def arcs(self) -> dict[tuple[TaskIdx, TaskIdx], BoolVarT]:
        """
        Returns the arcs of the sequence variable.
        """
        return self._arcs

    @property
    def is_active(self) -> bool:
        """
        Returns whether the sequence variable is active.
        """
        return self._is_active

    def activate(self, model: CpModel):
        """
        Activates the sequence variable by creating all relevant literals.
        """
        if self.is_active:
            return

        self._is_active = True

        nodes = [*self._tasks, self.DUMMY]
        self._arcs = {
            (i, j): model.new_bool_var(f"{i}->{j}")
            for i in nodes
            for j in nodes
        }


@dataclass
class BreakVar:
    """
    Represents a discrete choice for break interruption duration for a mode.

    When a task allows breaks (`allow_breaks=True`), the solver must determine
    how much break time will interrupt the task's execution. This depends on
    both the task's start time and duration. To model this efficiently, all
    possible break durations are pre-computed and represented as discrete
    choices, where exactly one choice is selected per mode.

    Parameters
    ----------
    selected
        Boolean variable indicating whether this break duration choice is
        active. Exactly one BreakVar per selected mode will must be selected.
    start_domain
        Valid start time domain for this break duration. Tasks can only start
        at times within this domain if this break duration is selected.
    duration
        Total duration of break interruptions for this choice. This represents
        the amount of time the task will be interrupted by resource breaks.

    Notes
    -----
    Multiple BreakVar instances exist per mode because different start times
    can result in different total break durations. The solver selects the
    appropriate choice based on the task's actual start time.

    Examples
    --------
    For a 4-hour task with breaks at [2-3] and [6-7]:
    - BreakVar(duration=0): start times that avoid all breaks
    - BreakVar(duration=1): start times that hit exactly one break
    - BreakVar(duration=2): start times that hit both breaks
    """

    selected: BoolVarT
    start_domain: Domain
    duration: int


class Variables:
    """
    Manages the core variables of the OR-Tools model.
    """

    def __init__(self, model: CpModel, data: ProblemData):
        self._model = model
        self._data = data

        self._job_vars = self._make_job_variables()
        self._task_vars = self._make_task_variables()
        self._mode_vars = [model.new_bool_var("") for _ in self._data.modes]
        self._assign_vars = self._make_assign_variables(self._task_vars)
        self._demand_vars = self._make_demand_variables()
        self._sequence_vars = self._make_sequence_variables()

        # Variables below are lazily created.
        self._break_vars: list[list[BreakVar]] | None = None
        self._makespan_var: IntVar | None = None
        self._is_tardy_vars: list[IntVar] | None = None
        self._flow_time_vars: list[IntVar] | None = None
        self._tardiness_vars: list[IntVar] | None = None
        self._earliness_vars: list[IntVar] | None = None
        self._max_tardiness_var: IntVar | None = None

    @property
    def job_vars(self) -> list[JobVar]:
        """
        Returns the job variables.
        """
        return self._job_vars

    @property
    def task_vars(self) -> list[TaskVar]:
        """
        Returns the task variables.
        """
        return self._task_vars

    @property
    def mode_vars(self) -> list[ModeVar]:
        """
        Returns the mode variables.
        """
        return self._mode_vars

    @property
    def assign_vars(self) -> dict[TaskResIdcs, OptionalIntervalVar]:
        """
        Retruns the assignment variables.
        """
        return self._assign_vars

    @property
    def demand_vars(self) -> dict[TaskResIdcs, IntVar]:
        """
        Returns the demand variables.
        """
        return self._demand_vars

    @property
    def sequence_vars(self) -> dict[int, SequenceVar]:
        """
        Returns the sequence variables.
        """
        return self._sequence_vars

    @property
    def break_vars(self) -> list[list[BreakVar]]:
        """
        Returns the break variables for each mode.
        """
        if self._break_vars is not None:
            return self._break_vars

        self._break_vars = self._make_break_variables()
        return self._break_vars

    @property
    def makespan_var(self) -> IntVar:
        """
        Returns the makespan variable, creating it if it does not exist.
        """
        if self._makespan_var is not None:
            return self._makespan_var

        self._makespan_var = self._make_makespan_variable()
        return self._makespan_var

    @property
    def is_tardy_vars(self) -> list[IntVar]:
        """
        Returns the Boolean variables indicating whether each job is tardy,
        creating them if they do not exist.
        """
        if self._is_tardy_vars is not None:
            return self._is_tardy_vars

        self._is_tardy_vars = self._make_is_tardy_variables()
        return self._is_tardy_vars

    @property
    def flow_time_vars(self) -> list[IntVar]:
        """
        Returns the flow time variables for each job, creating them if they do
        not exist.
        """
        if self._flow_time_vars is not None:
            return self._flow_time_vars

        self._flow_time_vars = self._make_flow_time_variables()
        return self._flow_time_vars

    @property
    def tardiness_vars(self) -> list[IntVar]:
        """
        Returns the tardiness variables for each job, creating them if they do
        not exist.
        """
        if self._tardiness_vars is not None:
            return self._tardiness_vars

        self._tardiness_vars = self._make_tardiness_variables()
        return self._tardiness_vars

    @property
    def earliness_vars(self) -> list[IntVar]:
        """
        Returns the earliness variables for each job, creating them if they do
        not exist.
        """
        if self._earliness_vars is not None:
            return self._earliness_vars

        self._earliness_vars = self._make_earliness_variables()
        return self._earliness_vars

    @property
    def max_tardiness_var(self) -> IntVar:
        """
        Returns the maximum tardiness variable, creating it if it does not
        exist.
        """
        if self._max_tardiness_var is not None:
            return self._max_tardiness_var

        self._max_tardiness_var = self._make_max_tardiness_variable()
        return self._max_tardiness_var

    def res2assign(self, idx: int) -> list[OptionalIntervalVar]:
        """
        Returns all assignment variables for the given resource.
        """
        items = self.assign_vars.items()
        return [var for (_, res_idx), var in items if res_idx == idx]

    def res2demand(self, idx: int) -> list[IntVar]:
        """
        Returns all demand variables for the given resource.
        """
        items = self.demand_vars.items()
        return [var for (_, res_idx), var in items if res_idx == idx]

    def _make_job_variables(self) -> list[JobVar]:
        """
        Creates an interval variable for each job.
        """
        model, data = self._model, self._data
        variables = []

        for idx, job in enumerate(data.jobs):
            name = f"J{idx}"
            start = model.new_int_var(
                lb=job.release_date,
                ub=MAX_VALUE,
                name=f"{name}_start",
            )
            duration = model.new_int_var(
                lb=0,
                ub=min(job.deadline - job.release_date, MAX_VALUE),
                name=f"{name}_duration",
            )
            end = model.new_int_var(
                lb=0,
                ub=min(job.deadline, MAX_VALUE),
                name=f"{name}_end",
            )
            interval = model.new_interval_var(
                start, duration, end, f"{name}_interval"
            )
            variables.append(JobVar(interval))

        return variables

    def _make_task_variables(self) -> list[TaskVar]:
        """
        Creates an interval variable for each task.
        """
        model, data = self._model, self._data
        variables = []

        for idx, task in enumerate(data.tasks):
            name = f"T{idx}"
            present = (
                model.new_bool_var(f"{name}_present")
                if task.optional
                else model.new_constant(True)
            )

            start = model.new_int_var(lb=0, ub=MAX_VALUE, name=f"{name}_start")
            model.add(start >= task.earliest_start).only_enforce_if(present)
            model.add(start <= task.latest_start).only_enforce_if(present)

            end = model.new_int_var(lb=0, ub=MAX_VALUE, name=f"{name}_end")
            model.add(end >= task.earliest_end).only_enforce_if(present)
            model.add(end <= task.latest_end).only_enforce_if(present)

            processing = model.new_int_var(0, MAX_VALUE, f"{name}_processing")
            modes = [data.modes[mode_idx] for mode_idx in data.task2modes(idx)]
            mode_durations = [mode.duration for mode in modes]
            if task.optional:
                mode_durations.append(0)  # 0 is OK if task is absent

            model.add_linear_expression_in_domain(
                processing, Domain.from_values(mode_durations)
            )

            ub_idle = MAX_VALUE if task.allow_idle else 0
            idle = model.new_int_var(0, ub_idle, f"{name}_idle")

            ub_breaks = MAX_VALUE if task.allow_breaks else 0
            breaks = model.new_int_var(0, ub_breaks, f"{name}_breaks")

            duration = model.new_int_var(0, MAX_VALUE, f"{name}_duration")
            model.add(duration == processing + idle + breaks)

            interval = model.new_optional_interval_var(
                start, duration, end, present, f"{name}_interval"
            )
            variables.append(
                TaskVar(interval, present, processing, idle, breaks)
            )

        return variables

    def _make_assign_variables(
        self, task_vars: list[TaskVar]
    ) -> dict[TaskResIdcs, OptionalIntervalVar]:
        """
        Creates an optional interval variable for each task-resource pair.
        """
        model, data = self._model, self._data
        variables = {}

        for task_idx, task_var in enumerate(task_vars):
            for res_idx in data.task2resources(task_idx):
                name = f"A_{task_idx}_{res_idx}"
                present = model.new_bool_var(f"{name}_present")
                interval = model.new_optional_interval_var(
                    task_var.start,
                    task_var.duration,
                    task_var.end,
                    present,
                    f"{name}_interval",
                )
                var = OptionalIntervalVar(interval, present)
                variables[task_idx, res_idx] = var

        return variables

    def _make_demand_variables(self) -> dict[TaskResIdcs, IntVar]:
        """
        Creates a integer demand variable for each task-resource pair.
        """
        model, data = self._model, self._data
        variables = {}

        for task_idx in range(data.num_tasks):
            for res_idx in data.task2resources(task_idx):
                name = f"{task_idx}_{res_idx}"
                demand = model.new_int_var(0, MAX_VALUE, f"{name}_demand")
                variables[task_idx, res_idx] = demand

        return variables

    def _make_sequence_variables(self) -> dict[ResourceIdx, SequenceVar]:
        """
        Creates a sequence variable for each machine.
        """
        data = self._data
        variables: dict[ResourceIdx, SequenceVar] = {}

        for idx in data.machine_idcs:
            tasks = {data.modes[m].task for m in data.resource2modes(idx)}
            variables[idx] = SequenceVar(sorted(tasks))

        return variables

    def _make_break_variables(self) -> list[list[BreakVar]]:
        """
        Creates the break variables.
        """
        model, data = self._model, self._data
        variables: list[list[BreakVar]] = []

        for mode in data.modes:
            # For single-resource modes, breaks map directly to individual
            # resource breaks. For multi-resource modes, breaks may represent
            # combined breaks (e.g., when resources have overlapping breaks).
            all_breaks = []
            for res_idx in mode.resources:
                all_breaks.extend(data.resources[res_idx].breaks)

            breaks = merge(all_breaks)
            partition = partition_task_start_by_break_overlap(
                breaks, mode.duration
            )

            break_vars = []
            for duration, start_domain in partition.items():
                select = model.new_bool_var("")
                break_vars.append(BreakVar(select, start_domain, duration))

            variables.append(break_vars)

        return variables

    def _make_makespan_variable(self) -> IntVar:
        """
        Creates the makespan variable.
        """
        makespan_var = self._model.new_int_var(0, MAX_VALUE, "makespan")

        if self._task_vars:
            # Need at least one task to enforce this constraint.
            completion_times = [var.end for var in self.task_vars]
            self._model.add_max_equality(makespan_var, completion_times)

        return makespan_var

    def _make_is_tardy_variables(self) -> list[IntVar]:
        """
        Creates the Boolean variables indicating whether each job is tardy.
        """
        model, data = self._model, self._data
        is_tardy_vars = []

        for job, job_var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            is_tardy = model.new_bool_var(f"is_tardy_{job}")
            model.add(job_var.end > job.due_date).only_enforce_if(is_tardy)
            model.add(job_var.end <= job.due_date).only_enforce_if(~is_tardy)
            is_tardy_vars.append(is_tardy)

        return is_tardy_vars

    def _make_flow_time_variables(self) -> list[IntVar]:
        """
        Creates the flow time variables for each job.
        """
        model, data = self._model, self._data
        flow_time_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            flow_time = model.new_int_var(0, MAX_VALUE, f"flow_time_{job}")
            model.add_max_equality(flow_time, [0, var.end - job.release_date])
            flow_time_vars.append(flow_time)

        return flow_time_vars

    def _make_tardiness_variables(self) -> list[IntVar]:
        """
        Creates the tardiness variables for each job.
        """
        model, data = self._model, self._data
        tardiness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            tardiness = model.new_int_var(0, MAX_VALUE, f"tardiness_{job}")
            model.add_max_equality(tardiness, [0, var.end - job.due_date])
            tardiness_vars.append(tardiness)

        return tardiness_vars

    def _make_earliness_variables(self) -> list[IntVar]:
        """
        Creates the earliness variables for each job.
        """
        model, data = self._model, self._data
        earliness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            earliness = model.new_int_var(0, MAX_VALUE, f"earliness_{job}")
            model.add_max_equality(earliness, [0, job.due_date - var.end])
            earliness_vars.append(earliness)

        return earliness_vars

    def _make_max_tardiness_variable(self) -> IntVar:
        """
        Creates the maximum tardiness variable.
        """
        model = self._model
        max_tardiness_var = model.new_int_var(0, MAX_VALUE, "max_tardiness")

        if self._job_vars:
            # Need at least one job to enforce this constraint.
            tardiness_vars = [
                job.weight * var
                for job, var in zip(self._data.jobs, self.tardiness_vars)
            ]
            model.add_max_equality(max_tardiness_var, tardiness_vars)

        return max_tardiness_var

    def warmstart(self, solution: Solution):
        """
        Warmstarts the variables based on the given solution.
        """
        model, data = self._model, self._data
        job_vars, task_vars, assign_vars = (
            self.job_vars,
            self.task_vars,
            self.assign_vars,
        )
        sol_tasks = solution.tasks

        model.clear_hints()

        # Job related variables.
        max_tardiness = 0
        for task_idx in range(data.num_jobs):
            job = data.jobs[task_idx]
            job_var = job_vars[task_idx]
            job_sol_tasks = [sol_tasks[task] for task in job.tasks]

            job_start = min(task.start for task in job_sol_tasks)
            job_end = max(task.end for task in job_sol_tasks)
            job_duration = job_end - job_start

            model.add_hint(job_var.start, job_start)  # type: ignore
            model.add_hint(job_var.duration, job_duration)  # type: ignore
            model.add_hint(job_var.end, job_end)  # type: ignore

            if data.objective.weight_total_flow_time > 0:
                flow_time = job_end - job.release_date
                model.add_hint(self.flow_time_vars[task_idx], flow_time)

            if job.due_date is not None:
                if data.objective.weight_tardy_jobs > 0:
                    is_tardy = job_end > job.due_date
                    model.add_hint(self.is_tardy_vars[task_idx], is_tardy)

                if data.objective.weight_total_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    model.add_hint(self.tardiness_vars[task_idx], tardiness)

                if data.objective.weight_total_earliness > 0:
                    earliness = max(0, job.due_date - job_end)
                    model.add_hint(self.earliness_vars[task_idx], earliness)

                if data.objective.weight_max_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    max_tardiness = max(max_tardiness, tardiness)

        if data.objective.weight_max_tardiness > 0:
            model.add_hint(self.max_tardiness_var, max_tardiness)

        if data.objective.weight_makespan > 0:
            model.add_hint(self.makespan_var, solution.makespan)

        # Task and mode related variables.
        for task_idx in range(data.num_tasks):
            task_var = task_vars[task_idx]
            sol_task = solution.tasks[task_idx]

            model.add_hint(task_var.start, sol_task.start)  # type: ignore
            model.add_hint(task_var.end, sol_task.end)  # type: ignore
            model.add_hint(task_var.idle, sol_task.idle)
            model.add_hint(task_var.breaks, sol_task.breaks)
            model.add_hint(task_var.processing, sol_task.processing)
            model.add_hint(task_var.duration, sol_task.duration)  # type: ignore

            if data.tasks[task_idx].optional:
                # OR-Tools complains about adding hints to interval
                # variables that are always present.
                model.add_hint(task_var.present, sol_task.present)

            for mode_idx in data.task2modes(task_idx):
                mode_var = self.mode_vars[mode_idx]
                mode_selected = mode_idx == sol_task.mode
                model.add_hint(mode_var, mode_selected)

                # Break related variables.
                for break_var in self.break_vars[mode_idx]:
                    selected = (
                        break_var.duration == sol_task.breaks and mode_selected
                    )
                    model.add_hint(break_var.selected, selected)

            # Assignment and demand related variables.
            mode_data = data.modes[sol_task.mode]
            res2demands = dict(zip(mode_data.resources, mode_data.demands))

            for res_idx in data.task2resources(task_idx):
                assign_var = assign_vars[task_idx, res_idx]
                is_present = res_idx in sol_task.resources
                model.add_hint(assign_var.present, is_present)

                demand_var = self.demand_vars[task_idx, res_idx]
                model.add_hint(demand_var, res2demands.get(res_idx, 0))

        # Sequencing related variables.
        for res_idx in data.machine_idcs:
            seq_var = self.sequence_vars[res_idx]
            if not seq_var.is_active:
                continue

            # Identify the tasks assigned to this machine.
            tasks = {data.modes[m].task for m in data.resource2modes(res_idx)}
            assigned = {
                idx for idx in tasks if res_idx in sol_tasks[idx].resources
            }

            # Identify the first and last task in the sequence.
            def task_start(idx):
                return sol_tasks[idx].start

            first = min(assigned, default=None, key=task_start)
            last = max(assigned, default=None, key=task_start)

            for (idx1, idx2), arc in seq_var.arcs.items():
                if idx1 == seq_var.DUMMY and idx2 == seq_var.DUMMY:
                    hint = not assigned
                elif idx1 == seq_var.DUMMY:
                    hint = idx2 == first
                elif idx2 == seq_var.DUMMY:
                    hint = idx1 == last
                elif idx1 == idx2:
                    hint = idx1 not in assigned
                else:
                    # TODO There's an edge case when the task duration is 0.
                    # Revisit after #257.
                    hint = (
                        idx1 in assigned
                        and idx2 in assigned
                        and sol_tasks[idx1].start < sol_tasks[idx2].start
                    )

                model.add_hint(arc, hint)
