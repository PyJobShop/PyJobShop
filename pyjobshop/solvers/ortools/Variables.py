from dataclasses import dataclass
from typing import TypeAlias

from ortools.sat.python.cp_model import (
    BoolVarT,
    CpModel,
    Domain,
    IntervalVar,
    IntVar,
    LinearExprT,
)

import pyjobshop.solvers.utils as utils
from pyjobshop.constants import MAX_VALUE
from pyjobshop.ProblemData import ProblemData
from pyjobshop.Solution import Solution

TaskIdx = int
ResourceIdx = int
ModeVar: TypeAlias = IntVar  # actually BoolVarT


@dataclass
class JobVar:
    """
    Variables that represent a job in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the job.
    """

    interval: IntervalVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class TaskVar:
    """
    Variables that represent a task in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the task.
    """

    interval: IntervalVar

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


@dataclass
class AssignVar:
    """
    Variables that represent a task-resource assignment in the problem.

    Parameters
    ----------
    interval
        The interval variable representing the task-resource assignment.
    present
        The Boolean variable indicating whether the interval is present.
    demand
        The demand consumed by the task-resource pair.
    """

    interval: IntervalVar
    present: BoolVarT
    demand: LinearExprT

    @property
    def start(self) -> LinearExprT:
        return self.interval.start_expr()

    @property
    def duration(self) -> LinearExprT:
        return self.interval.size_expr()

    @property
    def end(self) -> LinearExprT:
        return self.interval.end_expr()


class SequenceVar:
    """
    Represents the sequence of interval variables for all tasks that may
    be assigned to this machine.

    Parameters
    ----------
    tasks
        The list of task indices that can be assigned to this resource. Tasks
        combined with a dummy node represent the graph of this variable.

    Attributes
    ----------
    arcs
        The arc literals between each pair of intervals indicating whether
        intervals are scheduled directly behind each other. Includes arcs
        to and from a dummy node for each interval.
    is_active
        A Boolean that indicates whether the sequence is active, meaning that a
        circuit constraint must be added for this machine. Default ``False``.

    Notes
    -----
    A sequence variable represents a complete graph of the tasks that can be
    assigned to a resource. The nodes include all tasks and a dummy node, which
    is required to obtain a correct permutation of present tasks in this
    sequence. The arcs of a sequence variable are lazily generated by the
    ``activate()`` method. This avoids creating arcs when it's not used in the
    model, because creating them is very expensive (takes quadratic time).

    """

    DUMMY = -1

    def __init__(self, tasks: list[int]):
        self._tasks = tasks
        self._arcs: dict[tuple[TaskIdx, TaskIdx], BoolVarT] = {}
        self._is_active = False

    @property
    def arcs(self) -> dict[tuple[TaskIdx, TaskIdx], BoolVarT]:
        """
        Returns the arcs of the sequence variable.
        """
        return self._arcs

    @property
    def is_active(self) -> bool:
        """
        Returns whether the sequence variable is active.
        """
        return self._is_active

    def activate(self, model: CpModel):
        """
        Activates the sequence variable by creating all relevant literals.
        """
        if self.is_active:
            return

        self._is_active = True

        nodes = self._tasks + [self.DUMMY]
        self._arcs = {
            (i, j): model.new_bool_var(f"{i}->{j}")
            for i in nodes
            for j in nodes
        }


class Variables:
    """
    Manages the core variables of the OR-Tools model.
    """

    def __init__(self, model: CpModel, data: ProblemData):
        self._model = model
        self._data = data

        self._job_vars = self._make_job_variables()
        self._task_vars = self._make_task_variables()
        self._mode_vars = [model.new_bool_var("") for _ in self._data.modes]
        self._assign_vars = self._make_assign_variables(self._task_vars)
        self._sequence_vars = self._make_sequence_variables()

        # Variables below are lazily created.
        self._makespan_var: IntVar | None = None
        self._is_tardy_vars: list[IntVar] | None = None
        self._flow_time_vars: list[IntVar] | None = None
        self._tardiness_vars: list[IntVar] | None = None
        self._earliness_vars: list[IntVar] | None = None
        self._max_tardiness_var: IntVar | None = None

    @property
    def job_vars(self) -> list[JobVar]:
        """
        Returns the job variables.
        """
        return self._job_vars

    @property
    def task_vars(self) -> list[TaskVar]:
        """
        Returns the task variables.
        """
        return self._task_vars

    @property
    def assign_vars(self) -> dict[tuple[TaskIdx, ResourceIdx], AssignVar]:
        """
        Retruns the assignment variables.
        """
        return self._assign_vars

    @property
    def mode_vars(self) -> list[ModeVar]:
        """
        Returns the mode variables.
        """
        return self._mode_vars

    @property
    def sequence_vars(self) -> dict[int, SequenceVar]:
        """
        Returns the sequence variables.
        """
        return self._sequence_vars

    @property
    def makespan_var(self) -> IntVar:
        """
        Returns the makespan variable, creating it if it does not exist.
        """
        if self._makespan_var is not None:
            return self._makespan_var

        self._makespan_var = self._make_makespan_variable()
        return self._makespan_var

    @property
    def is_tardy_vars(self) -> list[IntVar]:
        """
        Returns the Boolean variables indicating whether each job is tardy,
        creating them if they do not exist.
        """
        if self._is_tardy_vars is not None:
            return self._is_tardy_vars

        self._is_tardy_vars = self._make_is_tardy_variables()
        return self._is_tardy_vars

    @property
    def flow_time_vars(self) -> list[IntVar]:
        """
        Returns the flow time variables for each job, creating them if they do
        not exist.
        """
        if self._flow_time_vars is not None:
            return self._flow_time_vars

        self._flow_time_vars = self._make_flow_time_variables()
        return self._flow_time_vars

    @property
    def tardiness_vars(self) -> list[IntVar]:
        """
        Returns the tardiness variables for each job, creating them if they do
        not exist.
        """
        if self._tardiness_vars is not None:
            return self._tardiness_vars

        self._tardiness_vars = self._make_tardiness_variables()
        return self._tardiness_vars

    @property
    def earliness_vars(self) -> list[IntVar]:
        """
        Returns the earliness variables for each job, creating them if they do
        not exist.
        """
        if self._earliness_vars is not None:
            return self._earliness_vars

        self._earliness_vars = self._make_earliness_variables()
        return self._earliness_vars

    @property
    def max_tardiness_var(self) -> IntVar:
        """
        Returns the maximum tardiness variable, creating it if it does not
        exist.
        """
        if self._max_tardiness_var is not None:
            return self._max_tardiness_var

        self._max_tardiness_var = self._make_max_tardiness_variable()
        return self._max_tardiness_var

    def res2assign(self, idx: int) -> list[AssignVar]:
        """
        Returns all assignment variables for the given resource.
        """
        items = self.assign_vars.items()
        return [var for (_, res_idx), var in items if res_idx == idx]

    def _make_job_variables(self) -> list[JobVar]:
        """
        Creates an interval variable for each job.
        """
        model, data = self._model, self._data
        variables = []

        for idx, job in enumerate(data.jobs):
            name = f"J{idx}"
            start = model.new_int_var(
                lb=job.release_date,
                ub=MAX_VALUE,
                name=f"{name}_start",
            )
            duration = model.new_int_var(
                lb=0,
                ub=min(job.deadline - job.release_date, MAX_VALUE),
                name=f"{name}_duration",
            )
            end = model.new_int_var(
                lb=0,
                ub=min(job.deadline, MAX_VALUE),
                name=f"{name}_end",
            )
            interval = model.new_interval_var(
                start, duration, end, f"{name}_interval"
            )
            variables.append(JobVar(interval))

        return variables

    def _make_task_variables(self) -> list[TaskVar]:
        """
        Creates an interval variable for each task.
        """
        model, data = self._model, self._data
        variables = []
        task_durations = utils.compute_task_durations(data)

        for idx, task in enumerate(data.tasks):
            name = f"T{idx}"
            start = model.new_int_var(
                lb=task.earliest_start,
                ub=min(task.latest_start, MAX_VALUE),
                name=f"{name}_start",
            )
            if task.fixed_duration:
                duration = model.new_int_var_from_domain(
                    Domain.from_values(task_durations[idx]), f"{name}_duration"
                )
            else:
                duration = model.new_int_var(
                    lb=min(task_durations[idx]),
                    ub=MAX_VALUE,
                    name=f"{name}_duration",
                )
            end = model.new_int_var(
                lb=task.earliest_end,
                ub=min(task.latest_end, MAX_VALUE),
                name=f"{name}_end",
            )
            interval = model.new_interval_var(
                start, duration, end, f"interval_{task}"
            )
            variables.append(TaskVar(interval))

        return variables

    def _make_assign_variables(
        self, task_vars: list[TaskVar]
    ) -> dict[tuple[TaskIdx, ResourceIdx], AssignVar]:
        """
        Creates an optional interval variable for each task-resource pair.
        """
        model, data = self._model, self._data
        variables = {}

        for task_idx in range(data.num_tasks):
            # Only create assignment variables for (task, resource) pairs
            # that are actually used in the problem.
            resources = {
                res
                for mode in data.task2modes(task_idx)
                for res in data.modes[mode].resources
            }

            for res_idx in resources:
                name = f"A_{task_idx}_{res_idx}"
                task_var = task_vars[task_idx]
                present = model.new_bool_var(f"{name}_present")
                interval = model.new_optional_interval_var(
                    task_var.start,
                    task_var.duration,
                    task_var.end,
                    present,
                    f"{name}_interval",
                )
                demand = model.new_int_var(0, MAX_VALUE, f"{name}_demand")
                var = AssignVar(interval, present, demand)
                variables[task_idx, res_idx] = var

        return variables

    def _make_sequence_variables(self) -> dict[ResourceIdx, SequenceVar]:
        """
        Creates a sequence variable for each machine.
        """
        data = self._data
        variables: dict[ResourceIdx, SequenceVar] = {}

        for idx in data.machine_idcs:
            tasks = {data.modes[m].task for m in data.resource2modes(idx)}
            variables[idx] = SequenceVar(sorted(tasks))

        return variables

    def _make_makespan_variable(self) -> IntVar:
        """
        Creates the makespan variable.
        """
        makespan_var = self._model.new_int_var(0, MAX_VALUE, "makespan")

        if self._task_vars:
            # Need at least one task to enforce this constraint.
            completion_times = [var.end for var in self.task_vars]
            self._model.add_max_equality(makespan_var, completion_times)

        return makespan_var

    def _make_is_tardy_variables(self) -> list[IntVar]:
        """
        Creates the Boolean variables indicating whether each job is tardy.
        """
        model, data = self._model, self._data
        is_tardy_vars = []

        for job, job_var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            is_tardy = model.new_bool_var(f"is_tardy_{job}")
            model.add(job_var.end > job.due_date).only_enforce_if(is_tardy)
            model.add(job_var.end <= job.due_date).only_enforce_if(~is_tardy)
            is_tardy_vars.append(is_tardy)

        return is_tardy_vars

    def _make_flow_time_variables(self) -> list[IntVar]:
        """
        Creates the flow time variables for each job.
        """
        model, data = self._model, self._data
        flow_time_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            flow_time = model.new_int_var(0, MAX_VALUE, f"flow_time_{job}")
            model.add_max_equality(flow_time, [0, var.end - job.release_date])
            flow_time_vars.append(flow_time)

        return flow_time_vars

    def _make_tardiness_variables(self) -> list[IntVar]:
        """
        Creates the tardiness variables for each job.
        """
        model, data = self._model, self._data
        tardiness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            tardiness = model.new_int_var(0, MAX_VALUE, f"tardiness_{job}")
            model.add_max_equality(tardiness, [0, var.end - job.due_date])
            tardiness_vars.append(tardiness)

        return tardiness_vars

    def _make_earliness_variables(self) -> list[IntVar]:
        """
        Creates the earliness variables for each job.
        """
        model, data = self._model, self._data
        earliness_vars = []

        for job, var in zip(data.jobs, self._job_vars):
            assert job.due_date is not None
            earliness = model.new_int_var(0, MAX_VALUE, f"earliness_{job}")
            model.add_max_equality(earliness, [0, job.due_date - var.end])
            earliness_vars.append(earliness)

        return earliness_vars

    def _make_max_tardiness_variable(self) -> IntVar:
        """
        Creates the maximum tardiness variable.
        """
        model = self._model
        max_tardiness_var = model.new_int_var(0, MAX_VALUE, "max_tardiness")

        if self._job_vars:
            # Need at least one job to enforce this constraint.
            tardiness_vars = [
                job.weight * var
                for job, var in zip(self._data.jobs, self.tardiness_vars)
            ]
            model.add_max_equality(max_tardiness_var, tardiness_vars)

        return max_tardiness_var

    def warmstart(self, solution: Solution):
        """
        Warmstarts the variables based on the given solution.
        """
        model, data = self._model, self._data
        job_vars, task_vars, assign_vars = (
            self.job_vars,
            self.task_vars,
            self.assign_vars,
        )
        sol_tasks = solution.tasks

        model.clear_hints()

        # Job related variables.
        max_tardiness = 0
        for task_idx in range(data.num_jobs):
            job = data.jobs[task_idx]
            job_var = job_vars[task_idx]
            job_sol_tasks = [sol_tasks[task] for task in job.tasks]

            job_start = min(task.start for task in job_sol_tasks)
            job_end = max(task.end for task in job_sol_tasks)
            job_duration = job_end - job_start

            model.add_hint(job_var.start, job_start)  # type: ignore
            model.add_hint(job_var.duration, job_duration)  # type: ignore
            model.add_hint(job_var.end, job_end)  # type: ignore

            if data.objective.weight_total_flow_time > 0:
                flow_time = job_end - job.release_date
                model.add_hint(self.flow_time_vars[task_idx], flow_time)

            if job.due_date is not None:
                if data.objective.weight_tardy_jobs > 0:
                    is_tardy = job_end > job.due_date
                    model.add_hint(self.is_tardy_vars[task_idx], is_tardy)

                if data.objective.weight_total_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    model.add_hint(self.tardiness_vars[task_idx], tardiness)

                if data.objective.weight_total_earliness > 0:
                    earliness = max(0, job.due_date - job_end)
                    model.add_hint(self.earliness_vars[task_idx], earliness)

                if data.objective.weight_max_tardiness > 0:
                    tardiness = max(0, job_end - job.due_date)
                    max_tardiness = max(max_tardiness, tardiness)

        if data.objective.weight_max_tardiness > 0:
            model.add_hint(self.max_tardiness_var, max_tardiness)

        if data.objective.weight_makespan > 0:
            model.add_hint(self.makespan_var, solution.makespan)

        # Task and mode related variables.
        for task_idx in range(data.num_tasks):
            task_var = task_vars[task_idx]
            sol_task = solution.tasks[task_idx]
            task_duration = sol_task.end - sol_task.start

            model.add_hint(task_var.start, sol_task.start)  # type: ignore
            model.add_hint(task_var.duration, task_duration)  # type: ignore
            model.add_hint(task_var.end, sol_task.end)  # type: ignore

            for mode_idx in data.task2modes(task_idx):
                mode_var = self.mode_vars[mode_idx]
                model.add_hint(mode_var, mode_idx == sol_task.mode)

            mode_data = data.modes[sol_task.mode]
            res2demands = dict(zip(mode_data.resources, mode_data.demands))

            task_resources = set()
            for mode in data.task2modes(task_idx):
                task_resources.update(data.modes[mode].resources)

            for res_idx in task_resources:
                var = assign_vars[task_idx, res_idx]
                model.add_hint(var.present, res_idx in sol_task.resources)
                model.add_hint(var.demand, res2demands.get(res_idx, 0))  # type: ignore

        # Sequencing related variables.
        for res_idx in data.machine_idcs:
            seq_var = self.sequence_vars[res_idx]
            if not seq_var.is_active:
                continue

            tasks = {data.modes[m].task for m in data.resource2modes(res_idx)}
            present_tasks = {
                idx for idx in tasks if res_idx in sol_tasks[idx].resources
            }

            # Identify the first and last task in the sequence.
            first = min(present_tasks, key=lambda idx: sol_tasks[idx].start)
            last = max(present_tasks, key=lambda idx: sol_tasks[idx].start)

            for (idx1, idx2), arc in seq_var.arcs.items():
                if idx1 == seq_var.DUMMY and idx2 == seq_var.DUMMY:
                    hint = not present_tasks
                elif idx1 == seq_var.DUMMY:
                    hint = idx2 == first
                elif idx2 == seq_var.DUMMY:
                    hint = idx1 == last
                elif idx1 == idx2:
                    hint = idx1 not in present_tasks
                else:
                    # TODO There's an edge case when the task duration is 0.
                    # Revisit after #257.
                    hint = (
                        idx1 in present_tasks
                        and idx2 in present_tasks
                        and sol_tasks[idx1].start < sol_tasks[idx2].start
                    )

                model.add_hint(arc, hint)
